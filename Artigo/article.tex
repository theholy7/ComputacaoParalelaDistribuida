\documentclass[a4paper,prd,twocolumn,nofootinbib,superscriptaddress,floatfix]{revtex4}
%\documentclass[prd,twocolumn,nofootinbib,showpacs]{revtex4-1}

\usepackage{cancel}
\usepackage{graphicx}
\usepackage{epsfig}
\usepackage{amsmath,amsfonts,amssymb}
\usepackage[latin9]{inputenc}
\usepackage[portuguese]{babel} 
\usepackage{algorithm}
\usepackage{algorithmic}


\hyphenation{}
\begin{document}

%\linenumbers

\title{Lowest Common Subsequence - Serial and Parallel Implementation}

\author{José Antunes} 
\author{César Alves}
\author{Mauro Machado}

\affiliation{Departamento de Física, Instituto Superior Técnico, Universidade de Lisboa, Lisboa, Portugal}

\begin{abstract}
The Longest Common Subsequence (LCS) was implemented in a serial and parallel fashion. Our serial implementation creates a matrix that is run line by line. In the parallel version each anti-diagonal was calculated in sequence with each value being calculated in parallel.
\end{abstract}

\maketitle

\section{Introduction}
With this work we wish to study the difference in execution time between the serial and parallel implementation of the Longest Common Subsequence (LCS) algorithm. This is a relevant algorithm in the bioinformatics field where a comparison between two DNA sequences is needed.

Problems appear when sequences become very large and the serial implementation of the code starts to have a very long execution time.

Processors have evolved more in the direction of having multiple cores over faster speeds and, as such, the trivial answer to these longer execution times is to have a parallel approach to the problem.

The LCS algorithm takes two sequences, $X$ and $Y$, of different lengths and will use a matrix to compare them. The matrix will be filled with integer values depending on how each element and the previous ones compare to each other.

The basic structure of the algorithm is the following:

\[ c(i, j) = \left\{ 
  \begin{array}{l l}
    0 & \text{if $i, j = 0$}\\
    c(i-1, j-1) + 1 &  \text{if $i, j > 0$ $x_i = y_j$}\\
    max( c(i-1, j); c(i, j-1) ) &  \text{if $i, j > 0$ $x_i \neq y_j$}
  \end{array} \right.\]
and this creates a matrix which will give the longest subsequence.

\begin{figure}[h!]
  \centering
      \includegraphics[width=0.35\textwidth]{img/matrix_1.png}
  \caption{Filled matrix after LCS algorithm.~\cite{esquema}.}
   \label{fig:1}
\end{figure}

With this matrix it is only needed that we start from the highest number and walk to the left. We go to the upper diagonal if there is a mismatch between the numbers and left only if they match.

\begin{figure}[h!]
  \centering
      \includegraphics[width=0.35\textwidth]{img/matrix_2.png}
  \caption{Representation of the LCS walk.~\cite{esquema}.}
   \label{fig:2}
\end{figure}

We can achieve the LCS by selecting the letters corresponding to the indexes that make our walk move in the upper diagonal direction.
\section{Methods}
\subsection{Serial Implementation}
The implemented serial version was straightforward to implemente. The matrix was calculated element by element, line by line, taking advantage of the cache's Locality Principal, both spacial and temporal.
\vspace{2mm}

\begin{algorithm}
\caption{Serial LCS implementation}
\label{lcs-serial}
\begin{algorithmic}
\FOR{$i=0$ to $N$}
	\FOR{$j=0$ to $M$}
		\STATE Compute $C(i,j)$
	\ENDFOR
\ENDFOR
\end{algorithmic}
\end{algorithm}

Albeit being the easiest solution to implement, this is not the best method when it comes to transforming the code into an effective paralleled version.
%\begin{figure}[h!]
%  \centering
%      \includegraphics[width=0.5\textwidth]{esquema.png}
%  \caption{Circuito utilizado na construção da coluna~\cite{esquema}.}
%   \label{fig:2}
%\end{figure}

\subsection{Parallel Implementation}
The thought process for any parallelization revolves around computing as many simultaneous values as possible. The rule for being able to make these computations is that they don't depend on each other.

In the LCS algorithm, the dependencies for each cell are well defined in the algorithm.

\begin{figure}[h!]
  \centering
      \includegraphics[width=0.35\textwidth]{img/matrix_3.png}
  \caption{Data dependencies of each $C(i,j)$.~\cite{esquema}.}
   \label{fig:3}
\end{figure}

It is trivial to see that each cell $C(i,j)$ depends on either $C(i, j-1)$ and $C(i-1,j)$ or $C(i-1,j-1)$. Furthermore, it is easy to say that each element in an anti-diagonal can be computed in parallel, since there are no dependencies.

As such the implemented algorithm has the form:
\vspace{2mm}

\begin{algorithm}
\caption{Parallel LCS implementation}
\label{lcs-parallel}
\begin{algorithmic}
\FOR{$anti-diagonal=0$ to $N+M$}
	\FOR{$i=0$ to $N$}
		\STATE{j = anti-diagonal - i}
		\IF{i>0 || j>0}
		\STATE Compute $C(i,j)$
		\ENDIF
	\ENDFOR
\ENDFOR
\end{algorithmic}
\end{algorithm}

This implementation raises concerns over the cache usage, which is not being used as efficiently as it could be.

\section{Results}
METER AQUI AS TABELAS COM OS VALORES

\begin{center}
\begin{tabular}{c|c|c}
  \hline                       
  Data & Serial & Parallel \\
  \hline
  ex10.15.in & 5 & 6 \\
  ex150.200.in & 5 & 6 \\
  ex3k.8k.in & 5 & 6 \\
  ex18k.17k.in & 5 & 6 \\
  ex48k.30k.in & 8 & 9 \\
  \hline 
\end{tabular}
\end{center}

\section{Discussion}
DISCUTIR AQUI AS TABELAS

\section{Conclusions}
CONCLUIR CENAS

\vspace{-2mm}
\section{Aknowledgements}
We would like thank Professor José Monteiro and Professor José Costa, from IST-UL, for their time and help, for teaching us and shedding light over our doubts.

\begin{thebibliography}{99}

\bibitem{esquema}
K. Cantrell, "A Study of the Plasma Tweeter", B.Sc. Thesis, Ball State University (2011)

\bibitem{ideia}
M. Hopkins and T. Houlhan, "The Plasma Speaker: Construction and Characterization of both Full-bridge and Single-ended driving circuits", Project Report, University of Illinois at Urbana-Champaign (2012)

\bibitem{ideiageral}
D. Severinsen and G. Sen Gupta, "Design and Evaluation of Electronic Circuit for Plasma Speaker", Proceedings of the World Congress on Engineering 2013 Vol II (2013)

\bibitem{arstuff}
L. Wayne Sieck, John T. Herron, and David S. Green, Plasma Chem., Plasma P., Vol. 20, No. 2, 2000
\bibitem{arstuff2}
John T. Herron and David S. Green, Plasma Chem., Plasma P., Vol. 21, No. 3, 2001
\bibitem{arstuff3}
K.H. Becker, U. Kogelschatz, K.H. Schoenbach, R.J. Barker, "Non-Equilibrium Air Plasmas at Atmospheric Pressure", p. 130, Institute of Physics Publishing, Bristol, UK (2005)
\bibitem{Mathematica}
Wolfram Research, Inc., Mathematica, Version 9.0, Champaign, IL (2012).
\end{thebibliography}

\end{document}
